# 14500. 테트로미노
# https://www.acmicpc.net/problem/14500

import sys
input = sys.stdin.readline

# 테트로미노의 좌표 모음
tetrominoes = [

    # ㅁ 형태
    [(1, 0), (0, 1), (1, 1)],

    # ㅡ 형태와 해당 형태의 회전과 대칭
    [(0, 1), (0, 2), (0, 3)], [(1, 0), (2, 0), (3, 0)],

    # ㅗ 형태와 해당 형태의 회전과 대칭
    [(0, 1), (0, 2), (1, 1)], [(0, 1), (0, 2), (-1, 1)],
    [(1, 0), (2, 0), (1, 1)], [(1, 0), (2, 0), (1, -1)],

    # ㄱㄴ 형태와 해당 형태의 회전과 대칭
    [(1, 0), (1, 1), (2, 1)], [(1, 0), (1, -1), (2, -1)],
    [(0, 1), (1, 1), (1, 2)], [(0, 1), (-1, 1), (-1, 2)],
    
    # L 형태와 해당 형태의 회전과 대칭
    [(1, 0), (2, 0), (2, 1)], [(1, 0), (2, 0), (2, -1)],
    [(1, 0), (2, 0), (0, 1)], [(1, 0), (2, 0), (0, -1)],
    [(1, 0), (0, 1), (0, 2)], [(0, 1), (0, 2), (1, 2)],
    [(1, 0), (1, 1), (1, 2)], [(0, 1), (0, 2), (-1, 2)]
]

N, M = map(int, input().rstrip().split())
paper = [list(map(int, input().rstrip().split())) for _ in range(N)]

ans = 0

# 모든 칸에 모든 테트로미노 하나를 놓아
# 테트로미노가 놓인 칸에 쓰인 수들의 합을 확인
for i in range(N):
    for j in range(M):
        
        # 하나의 테트로미노를 선택해
        # 시작점에서 좌표값을 더해주며
        # 해당 테트로미노를 놓을 수 있는지 확인
        for tetromino in tetrominoes:

            # 시작점에 있는 수로
            # 수들의 합 초기값 설정
            cnt = paper[i][j]

            # 선택한 테트로미노의 좌표값을 시작점에 더해줌
            for t in tetromino:
                ni, nj = i+t[0], j+t[1]

                # 만약 범위에 있지 않았다면
                # 해당 테트로미노를 놓을 수 없으므로 break
                if not 0<=ni<N or not 0<=nj<M:
                    break

                # 그렇지 않다면 해당 칸의 수를 더해줌
                cnt += paper[ni][nj]
            
            # 하나의 테트로미노를 놓았다면
            # 놓인 칸의 수들의 합이 최대인지 확인
            else:
                ans = max(ans, cnt)

# 테트로미노가 놓인 칸에 쓰인
# 수들의 합의 최댓값을 출력
print(ans)